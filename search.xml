<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据框（一）：单表操作</title>
      <link href="/posts/9cecd8f.html"/>
      <url>/posts/9cecd8f.html</url>
      
        <content type="html"><![CDATA[<p>通常我们将<strong>EXCLE表格</strong>或者分隔符分割的<strong>文本文件</strong>导入R中进行处理，这些数据在R语言称为数据框也可以叫做数据集，数据框中的行、列也分别称为观测和变量。</p><p>应用于数据框的函数和R包有很多，目前对数据框处理速度比较快的两个R包是鼎鼎大名的<code>dplyr</code>包和<code>tidyr</code>包，这两个包最主要的三个作用分别是：</p><ul><li>单个数据框的操作</li><li>两个数据框的操作</li><li>数据框的重塑</li></ul><p>接下来我将通过三篇文章分别介绍这三类操作、首先介绍的是单个数据框的操作，若掌握了单个数据框的操作、基本上可以满足我们大部分关于数据框处理的需求，在介绍之前我想先回顾一下关于数据框处理的基础函数。</p><div class="table-container"><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td><code>rownames(mtcars)</code></td><td>查看数据框<code>mtcars</code>的行名</td></tr><tr><td><code>colnames(mtcars)</code></td><td>查看数据框的列名</td></tr><tr><td><code>dim(mtcars)</code></td><td>查看数据框的行数和列数</td></tr><tr><td><code>is.data.frame(mtcars)</code></td><td>查看是否为数据框</td></tr><tr><td><code>as.data.frame(mtcars)</code></td><td>转换为数据框</td></tr><tr><td><code>mtcars$cyl</code></td><td>若变量<code>cyl</code>在数据框<code>mtcars</code>中，则提取这一列，若不在则可以添加新的变量</td></tr></tbody></table></div><p>下面让我们正式进入数据框的世界！</p><h1 id="1-按行操作"><a href="#1-按行操作" class="headerlink" title="1 按行操作"></a>1 按行操作</h1><h2 id="1-1-过滤"><a href="#1-1-过滤" class="headerlink" title="1. 1 过滤"></a>1. 1 过滤</h2><p><code>dplyr</code>包中<code>filter()</code>函数筛选满足条件的行</p><pre><code>head(iris) #数据集##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species## 1          5.1         3.5          1.4         0.2  setosa## 2          4.9         3.0          1.4         0.2  setosa## 3          4.7         3.2          1.3         0.2  setosa## 4          4.6         3.1          1.5         0.2  setosa## 5          5.0         3.6          1.4         0.2  setosa## 6          5.4         3.9          1.7         0.4  setosafilter_iris = filter(iris, Sepal.Length &gt; 7) # 选择Sepal.Length&gt;7的行head(filter_iris)##   Sepal.Length Sepal.Width Petal.Length Petal.Width   Species## 1          7.1         3.0          5.9         2.1 virginica## 2          7.6         3.0          6.6         2.1 virginica## 3          7.3         2.9          6.3         1.8 virginica## 4          7.2         3.6          6.1         2.5 virginica## 5          7.7         3.8          6.7         2.2 virginica## 6          7.7         2.6          6.9         2.3 virginica</code></pre><p><code>filter()</code>函数可以进行的逻辑型操作（<strong>TRUE、FALSE</strong>）和布尔型操作（<strong>或、且、非</strong>）：</p><div class="table-container"><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td><code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></td><td>大于、小于、大于等于、小于等于</td></tr><tr><td><code>is.na()</code></td><td>缺失值</td></tr><tr><td><code>!is.na()</code></td><td>非缺失值</td></tr><tr><td><code>%in%</code></td><td>存在</td></tr><tr><td>\\\</td><td></td><td></td></tr><tr><td><code>&amp;</code></td><td>且</td></tr><tr><td><code>!</code></td><td>非</td></tr></tbody></table></div><p><code>limma包</code>中<code>avereps()</code>函数对某列中相同元素所在的行取均值</p><pre><code>library(limma)avereps(mtcars, ID = mtcars$cyl) # 按&#39;cyl&#39;列取均值##        mpg cyl     disp        hp     drat       wt     qsec        vs## 6 19.74286   6 183.3143 122.28571 3.585714 3.117143 17.97714 0.5714286## 4 26.66364   4 105.1364  82.63636 4.070909 2.285727 19.13727 0.9090909## 8 15.10000   8 353.1000 209.21429 3.229286 3.999214 16.77214 0.0000000##          am     gear     carb## 6 0.4285714 3.857143 3.428571## 4 0.7272727 4.090909 1.545455## 8 0.1428571 3.285714 3.500000</code></pre><h2 id="1-2-排序"><a href="#1-2-排序" class="headerlink" title="1.2 排序"></a>1.2 排序</h2><p><code>arrange()</code>函数按某列值的大小对数据集进行排序</p><p><strong>升序</strong></p><pre><code>arrange_mpg = arrange(mtcars, mpg) head(arrange_mpg)##    mpg cyl disp  hp drat    wt  qsec vs am gear carb## 1 10.4   8  472 205 2.93 5.250 17.98  0  0    3    4## 2 10.4   8  460 215 3.00 5.424 17.82  0  0    3    4## 3 13.3   8  350 245 3.73 3.840 15.41  0  0    3    4## 4 14.3   8  360 245 3.21 3.570 15.84  0  0    3    4## 5 14.7   8  440 230 3.23 5.345 17.42  0  0    3    4## 6 15.0   8  301 335 3.54 3.570 14.60  0  1    5    8</code></pre><p><strong>降序</strong></p><pre><code>desc_arrange_mpg = arrange(mtcars, desc(mpg))head(desc_arrange_mpg)##    mpg cyl  disp  hp drat    wt  qsec vs am gear carb## 1 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1## 2 32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1## 3 30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2## 4 30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2## 5 27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1## 6 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2</code></pre><h2 id="1-3-添加新行"><a href="#1-3-添加新行" class="headerlink" title="1.3 添加新行"></a>1.3 添加新行</h2><p><code>add_row()</code>函数可以在指定的行前后添加新的一行</p><pre><code>head(faithful)##   eruptions waiting## 1     3.600      79## 2     1.800      54## 3     3.333      74## 4     2.283      62## 5     4.533      85## 6     2.883      55# 在第二行之前加上一行df1 = add_row(faithful, .before = 2,eruptions = 1.1, waiting = 1.3)head(df1)##   eruptions waiting## 1     3.600    79.0## 2     1.100     1.3## 3     1.800    54.0## 4     3.333    74.0## 5     2.283    62.0## 6     4.533    85.0# 在第二行之后加上一行df2 = add_row(faithful, .after  = 2,eruptions = 2.22, waiting = 2.23)head(df2)##   eruptions waiting## 1     3.600   79.00## 2     1.800   54.00## 3     2.220    2.23## 4     3.333   74.00## 5     2.283   62.00## 6     4.533   85.00</code></pre><h1 id="2-按列操作"><a href="#2-按列操作" class="headerlink" title="2 按列操作"></a>2 按列操作</h1><h2 id="2-1-过滤"><a href="#2-1-过滤" class="headerlink" title="2.1 过滤"></a>2.1 过滤</h2><p>用<code>select()</code>函数对数据集按列进行筛选，但是<code>select()</code>函数的功能在实际应用中并不多，基础函数就已经可以满足了，所以就简单记录一下，可能以后会用到。</p><p><strong>示例数据</strong></p><pre><code>iris = iris[1:3,]iris##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species## 1          5.1         3.5          1.4         0.2  setosa## 2          4.9         3.0          1.4         0.2  setosa## 3          4.7         3.2          1.3         0.2  setosa</code></pre><p>变量名筛选</p><pre><code>select(iris, Sepal.Length, Sepal.Width)##   Sepal.Length Sepal.Width## 1          5.1         3.5## 2          4.9         3.0## 3          4.7         3.2</code></pre><p>选择变量名中以<code>Petal</code>开头的变量</p><pre><code>select(iris, starts_with(&quot;Petal&quot;))##    Petal.Length Petal.Width## 1           1.4         0.2## 2           1.4         0.2## 3           1.3         0.2</code></pre><p>选择变量名中以<code>Width</code>结尾的变量</p><pre><code>select(iris, ends_with(&quot;Width&quot;))##    Sepal.Width Petal.Width## 1          3.5         0.2## 2          3.0         0.2## 3          3.2         0.2</code></pre><p>更换变量所在位置</p><pre><code># 将变量Species放置在第一列select(iris, Species, everything())##    Species Sepal.Length Sepal.Width Petal.Length Petal.Width## 1   setosa          5.1         3.5          1.4         0.2## 2   setosa          4.9         3.0          1.4         0.2## 3   setosa          4.7         3.2          1.3         0.2# 将变量Sepal.Length放置在最后一列select(iris, -Sepal.Length, Sepal.Length)##    Sepal.Width Petal.Length Petal.Width Species Sepal.Length## 1          3.5          1.4         0.2  setosa          5.1## 2          3.0          1.4         0.2  setosa          4.9## 3          3.2          1.3         0.2  setosa          4.7</code></pre><p>选择两个变量之间所以的变量</p><pre><code>select(iris,Sepal.Length:Petal.Length)##   Sepal.Length Sepal.Width Petal.Length## 1          5.1         3.5          1.4## 2          4.9         3.0          1.4## 3          4.7         3.2          1.3</code></pre><h2 id="2-2-添加新列"><a href="#2-2-添加新列" class="headerlink" title="2.2 添加新列"></a>2.2 添加新列</h2><p><strong>示例数据</strong></p><pre><code>df = mtcars[1:4,1:4]df##                 mpg cyl disp  hp## Mazda RX4      21.0   6  160 110## Mazda RX4 Wag  21.0   6  160 110## Datsun 710     22.8   4  108  93## Hornet 4 Drive 21.4   6  258 110</code></pre><p><code>mutate()</code>函数可以增加新的变量，值得注意的一点是添加新变量之后行名发生了变化，所以也没有基础函数好用。</p><pre><code>mutate(df,draft = c(3.90,3.90,3.85,3.08))##    mpg cyl disp  hp draft## 1 21.0   6  160 110  3.90## 2 21.0   6  160 110  3.90## 3 22.8   4  108  93  3.85## 4 21.4   6  258 110  3.08</code></pre><p>对已有变量进行运算，运算结果直接添加为新的变量</p><pre><code>dfmutate(df, gpm = 1/mpg)##    mpg cyl disp  hp        gpm## 1 21.0   6  160 110 0.04761905## 2 21.0   6  160 110 0.04761905## 3 22.8   4  108  93 0.04385965## 4 21.4   6  258 110 0.04672897</code></pre><h2 id="2-3-变量重命名"><a href="#2-3-变量重命名" class="headerlink" title="2.3 变量重命名"></a>2.3 变量重命名</h2><pre><code>rename(df,mpg1 = mpg)##                mpg1 cyl disp  hp## Mazda RX4      21.0   6  160 110## Mazda RX4 Wag  21.0   6  160 110## Datsun 710     22.8   4  108  93## Hornet 4 Drive 21.4   6  258 110</code></pre><h1 id="3-管道操作"><a href="#3-管道操作" class="headerlink" title="3 管道操作"></a>3 管道操作</h1><p><code>dplyr</code>包还有一个强大的功能是通过管道操作符<code>%&gt;%</code>进行管道操作，所谓管道操作就是让上一个处理的结果作为下一个处理的输入，这样可以减少变量（赋值对象）的命名，提高数据处理的效率，下面以一个例子来解释什么是管道操作。</p><pre><code>filter(mtcars,cyl == 6) %&gt;% arrange(mpg) %&gt;% select(cyl,mpg)##   cyl  mpg## 1   6 17.8## 2   6 18.1## 3   6 19.2## 4   6 19.7## 5   6 21.0## 6   6 21.0## 7   6 21.4</code></pre>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据框 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量</title>
      <link href="/posts/8c47f151.html"/>
      <url>/posts/8c47f151.html</url>
      
        <content type="html"><![CDATA[<p>之前我在<a href="https://bioinforwhite.github.io/posts/7fa6ac17.html" target="_blank" rel="noopener">数据结构</a>中初步介绍了向量的定义和类型以及对于向量的简单操作，如向量中的元素选取等，但是还有许多常用且相对复杂的操作并未提及，这篇文章的目就是详细的介绍我在学习过程中遇到的所有关于向量的操作。</p><h1 id="1-向量的创建"><a href="#1-向量的创建" class="headerlink" title="1 向量的创建"></a>1 向量的创建</h1><p><strong>创建空向量</strong></p><pre><code>c()## NULL</code></pre><p><strong>创建字符型向量</strong></p><pre><code>color = c(&#39;blue&#39;,&#39;yellow&#39;,&#39;red&#39;)names(color) = c(&#39;col1&#39;,&#39;col2&#39;,&#39;col3&#39;) # 命名color##     col1     col2     col3 ##   &quot;blue&quot; &quot;yellow&quot;    &quot;red&quot;</code></pre><p><strong>创建数值型向量：</strong></p><pre><code>1:4## [1] 1 2 3 4c(1:4)## [1] 1 2 3 4c(1,2,3,4)## [1] 1 2 3 4</code></pre><p><code>seq()</code>函数和 <code>rep()</code>函数创建<strong>特殊向量</strong></p><pre><code># 指定间隔生成向量seq(2,6, by = 0.5)## [1] 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0# 重复向量rep(1:4,2)## [1] 1 2 3 4 1 2 3 4# 重复向量中每个元素rep(c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;),each = 3)## [1] &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;b&quot; &quot;b&quot; &quot;b&quot; &quot;c&quot; &quot;c&quot; &quot;c&quot;</code></pre><p><code>append()</code>函数在现有向量后面添加向量</p><pre><code>a = 2:5a1 = append(a, 1:10, length(a))a1##  [1]  2  3  4  5  1  2  3  4  5  6  7  8  9 10</code></pre><h1 id="2-向量的操作"><a href="#2-向量的操作" class="headerlink" title="2 向量的操作"></a>2 向量的操作</h1><h2 id="2-1-选择向量中的元素"><a href="#2-1-选择向量中的元素" class="headerlink" title="2.1 选择向量中的元素"></a>2.1 选择向量中的元素</h2><p><strong>示例向量：</strong></p><pre><code>x = 1:10names(x) = paste(&#39;name&#39;, 1:10, sep = &#39;&#39;)x##  name1  name2  name3  name4  name5  name6  name7  name8  name9 name10 ##      1      2      3      4      5      6      7      8      9     10</code></pre><p><strong>通过位置选择</strong></p><pre><code>x[1]## name1 ##     1x[-1]##  name2  name3  name4  name5  name6  name7  name8  name9 name10 ##      2      3      4      5      6      7      8      9     10x[2:4]##  name2 name3 name4 ##      2     3     4x[-(2:4)]##  name1  name5  name6  name7  name8  name9 name10 ##      1      5      6      7      8      9     10x[c(2,4)]##  name2 name4 ##      2     4</code></pre><p><strong>根据值选择向量</strong></p><pre><code>x[x == 10]##  name10 ##      10 x[x &gt; 5 &amp; x &lt; 8]##  name6 name7 ##      6     7 x[x %in% c(2:5)]##  name2 name3 name4 name5 ##      2     3     4     5 x[match(c(3,1,6,5,11,13),x)]## name3 name1 name6 name5  &lt;NA&gt;  &lt;NA&gt; ##     3     1     6     5    NA    NAx[c(&#39;name1&#39;, &#39;name2&#39;)]##  name1 name2 ##      1     2which(x &gt; 5)##  name6  name7  name8  name9 name10 ##      6      7      8      9     10 which.max(x)##  name10 ##      10 which.min(x)##  name1 ##      1</code></pre><h2 id="2-2-数值型向量的运算"><a href="#2-2-数值型向量的运算" class="headerlink" title="2.2 数值型向量的运算"></a>2.2 数值型向量的运算</h2><pre><code>x + y          # 相加x - y          # 相减x / y          # 相除x ^ y          # 指数x %% y         # 求余x %/% y        # 整除abs(x)         # 求绝对值sqrt(x)        # 平方根log2(x)        # 2为底的对数log(x)         # e未底的对数log10(x)       # 10为底的对数log(x,base=n)  # 对X取n未底的对数exp(x)         # 指数sin(x)         # 正弦cox(x)         # 余弦tan(X)         # 正切ceiling(x)     # 取顶floor(x)       # 取底trunc(x)       # 取整round(x, digits=n) # 将 x 舍入为指定位的小数round(3.475, digits=2)## [1] 3.48signif(x, digits=n) # 将 x 舍入为指定的有效数字位数signif(3.475, digits=2) ## [1] 3.5</code></pre><h2 id="2-3-数值型向量的排序"><a href="#2-3-数值型向量的排序" class="headerlink" title="2.3 数值型向量的排序"></a>2.3 数值型向量的排序</h2><pre><code>x = c(3,5,4,1,6,7,8)#返回排序后的向量sort(x) ## [1] 1 3 4 5 6 7 8#返回元素对应的排名，升序rank(x)## [1] 2 4 3 1 5 6 7#返回排序后的向量元素在原向量中的索引，升序order(x)## [1] 4 1 3 2 5 6 7</code></pre><h2 id="2-4-字符型向量的操作"><a href="#2-4-字符型向量的操作" class="headerlink" title="2.4 字符型向量的操作"></a>2.4 字符型向量的操作</h2><pre><code>x = c(&#39;aa_11&#39;, &#39;ab_22&#39;, &#39;cc_33&#39;)#输出字符串的长度nchar(x)## [1] 5 5 5#输出向量的长度length(x)## [1] 3#字符串大写toupper(x)## [1] &quot;AA_11&quot; &quot;AB_22&quot; &quot;CC_33&quot;#字符串小写tolower(x)## [1] &quot;aa_11&quot; &quot;bb_22&quot; &quot;cc_33&quot;#提取向量中的字符串的子串substr(x, 1, 3)## [1] &quot;aa_&quot; &quot;ab_&quot; &quot;cc_&quot;#按&quot;_&quot;分割字符串，生成列表strsplit(x, &#39;_&#39;)## [[1]]## [1] &quot;aa&quot; &quot;11&quot;## [[2]]## [1] &quot;ab&quot; &quot;22&quot;## [[3]]## [1] &quot;cc&quot; &quot;33&quot;#合并向量y = c(&#39;A&#39;,&#39;B&#39;,&#39;C&#39;)paste(x,y,sep = &#39;.&#39;)## [1] &quot;aa_11.A&quot; &quot;ab_22.B&quot; &quot;cc_33.C&quot;#查看字符串是否在向量中，返回位置grep(&#39;a&#39;,x)## [1] 1 2</code></pre><h2 id="2-5-向量的去重"><a href="#2-5-向量的去重" class="headerlink" title="2.5 向量的去重"></a>2.5 向量的去重</h2><p><code>unique()</code>函数去重</p><pre><code>a = c(2,3,2,2)unique(a)## [1] 2 3</code></pre><p><code>duplicated()</code>函数去重</p><pre><code>vec = c(&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;c&#39;)index = duplicated(vec)index## [1] FALSE FALSE  TRUE FALSEvec[!index]## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot;</code></pre><h2 id="2-6-向量的交集、并集、补集"><a href="#2-6-向量的交集、并集、补集" class="headerlink" title="2.6 向量的交集、并集、补集"></a>2.6 向量的交集、并集、补集</h2><pre><code>x = 2:5y = 3:6z = 4:8#取交集intersect(x, y)## [1] 3 4 5#并集union(x,y)## [1] 2 3 4 5 6#取补集setdiff(x,y)## [1] 2#多个向量取交集Reduce(intersect,list(x,y,z))## [1] 4 5#多个向量取并集Reduce(union,list(x,y,z))## [1] 2 3 4 5 6 7 8#不同长度向量合并为数据框mylist = list(a = 1:3,b = 2:6,c = 2:8)data.frame(lapply(mylist, &quot;length&lt;-&quot;, max(lengths(mylist))))##    a  b c## 1  1  2 2## 2  2  3 3## 3  3  4 4## 4 NA  5 5## 5 NA  6 6## 6 NA NA 7## 7 NA NA 8</code></pre>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>目录和文件</title>
      <link href="/posts/57747df0.html"/>
      <url>/posts/57747df0.html</url>
      
        <content type="html"><![CDATA[<p>R语言可以对目录和文件进行一些简单的操作，比如常见的增删改查，文件的读取，文件的写入，对文件进行解压等。</p><h1 id="1-目录和文件增删改查"><a href="#1-目录和文件增删改查" class="headerlink" title="1 目录和文件增删改查"></a>1 目录和文件增删改查</h1><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th><th>操作对象</th></tr></thead><tbody><tr><td><code>getwd()</code></td><td>查看当前工作目录</td><td>目录</td></tr><tr><td><code>setwd()</code></td><td>设置当前工作目录</td><td>目录</td></tr><tr><td><code>dir.create()</code></td><td>创建目录</td><td>目录</td></tr><tr><td><code>list.dir()</code></td><td>列出目录下所有内容</td><td>目录</td></tr><tr><td><code>unlink(“tmp”,recursive=F)</code></td><td>如果<code>目录tmp</code>为空，删除<code>目录tmp</code></td><td>目录</td></tr><tr><td><code>unlink(“tmp”,recursive=T)</code></td><td>删除<code>目录tmp</code>，以及里面所有的内容</td><td>目录</td></tr><tr><td><code>file.exists()</code></td><td>检查某个目录和文件是否存在</td><td>目录/文件</td></tr><tr><td><code>file_test()</code></td><td>判断是一个目录还是文件，参数<code>-f</code>判断是否为文件,<code>-d</code>判断是否为目录</td><td>目录/文件</td></tr><tr><td><code>file.create()</code></td><td>创建文件</td><td>文件</td></tr><tr><td><code>file.remove()</code></td><td>移除文件</td><td>文件</td></tr><tr><td><code>file.rename()</code></td><td>对文件重命名</td><td>文件</td></tr><tr><td><code>file.copy(c(&quot;A&quot;) , &quot;tmp&quot;)</code></td><td><code>文件A</code>复制到<code>目录tmp</code>下</td><td>文件</td></tr></tbody></table></div><h1 id="2-文件解压"><a href="#2-文件解压" class="headerlink" title="2 文件解压"></a>2 文件解压</h1><pre><code># tar文件解压untar(tarfile  = &#39;GSE14407_RAW.tar&#39;,      # 输入文件      exdir    = &#39;GSE14407_RAW&#39;)          # 输出文件# gz文件解压library(R.utils)gunzip(filename = &#39;file_name.gz&#39;,  # 输入文件       destname = &#39;file_name&#39; )  # 输出文件</code></pre><h1 id="3-文件读取"><a href="#3-文件读取" class="headerlink" title="3 文件读取"></a>3 文件读取</h1><h2 id="3-1-文本文件读取"><a href="#3-1-文本文件读取" class="headerlink" title="3.1 文本文件读取"></a>3.1 文本文件读取</h2><p><code>read.table()</code>读取带有分隔符的文件，文件示例：</p><p><img src="/images/1571277912607.png" alt="文本文件"></p><p>原文件是以逗号为分隔符的文件，并且文件中含有空值。</p><p><strong>文件读取：</strong></p><pre><code>data = read.table(file = &#39;example.txt&#39;,                  comment.char = &quot;#&quot;,   # 不读取以&quot;#&quot;开头的行                  header = T,           # 第一行为列名                          sep = &#39;,&#39;,            # 以&quot;,&quot;为分隔符，常见还有&quot;\t&quot;为分隔符                  fill = T,             # 空值用NA代替                  check.names = F,      # 不检查列名                  stringsAsFactors = F) # 字符串不改为因子data##   mt-names mt-disp mt-wt mt-hp## 1    Mazda 160.000  2.62   110## 2    Mazda   2.875    NA   108## 3   Datsun   2.000    NA   123</code></pre><h2 id="3-2-EXCLE文件读取"><a href="#3-2-EXCLE文件读取" class="headerlink" title="3.2 EXCLE文件读取"></a>3.2 EXCLE文件读取</h2><blockquote><p>读取一个Excel文件的最好方式，就是在Excel中将其导出为一个逗号分隔文件（csv），并使用<code>read.table()</code>将其导入R中。</p></blockquote><p><code>readxl()</code>读取excle文件</p><pre><code>library(readxl)datasets &lt;- readxl_example(&quot;datasets.xlsx&quot;)#读取第一个工作表read_excel(datasets)#读取第二个工作表read_excel(datasets,2)#读取C1:E7内容read_excel(datasets,range = &quot;C1:E7&quot;)#读取148行以后的内容read_excel(datasets, skip = 148, col_names = FALSE)#读取前3行read_excel(datasets, n_max = 3)#读取102:151行read_excel(datasets, range = cell_rows(102:151), col_names = F)#读取B:D列read_excel(datasets, range = cell_cols(&quot;B:D&quot;))</code></pre>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多元统计学（一）：线性回归</title>
      <link href="/posts/fd6adf9d.html"/>
      <url>/posts/fd6adf9d.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-一元线性回归总体模型"><a href="#1-一元线性回归总体模型" class="headerlink" title="1 一元线性回归总体模型"></a>1 一元线性回归总体模型</h1><p><strong>回归方程</strong>：</p><script type="math/tex; mode=display">y = \beta_0+\beta_1x+\varepsilon\tag{1.1}</script><p>$\beta_0$ 和 $\beta_1$ 为回归系数； $\varepsilon$ 为随机误差。</p><p>若 $y$ 和 $x$ 分别进行 $n$ 次独立观测得到 $n$ 对观测值：$(y_i,x_i),i =1,2,\cdots,n$</p><script type="math/tex; mode=display">y_i = \beta_0+\beta_1x_i+\varepsilon_i,\quad i=1,2,\cdots,n\tag{1.2}</script><p>$x_i$ 为非随机变量，无观测误差，$y_i$ 为随机变量，随机性由 $\varepsilon_i$ 造成，$\varepsilon_i$ 为一个随机变量。</p><p>无论自变量 $x_i$ 取何值，模型总假设应变量 $y_i$ 的概率分布具有相等的方差 $\sigma^2$，并且假设误差项互不相关：</p><script type="math/tex; mode=display">\begin{align*}E(\varepsilon_i) &=0\\var(\varepsilon_i) &=\sigma^2\\cov(\varepsilon_i,\varepsilon_j) &= 0\end{align*}\tag{1.3}</script><p>在第 $i$ 次观测中，$x$ 的水平取 $x_i$ 时，<strong>相应 $y_i$ 的水平来自一个概率分布</strong>。</p><script type="math/tex; mode=display">\begin{align*}E(y_i) &= E(\beta_0+\beta_1x_i+\varepsilon_i)\\&= \beta_0+\beta_1x_i\end{align*}\tag{1.4}</script><p>或者：</p><script type="math/tex; mode=display">E(y_i\mid x_i) =\beta_0+\beta_1x_i\tag{1.5}</script><p><strong>理解：</strong></p><ul><li>对于一个给定的 $x_i$，随机变量 $y_i$ 的取值是未定的，但是 $y_i$ 的平均水平和 $x_i$ 存在着准确的线性关系。</li></ul><p>$y_i$ 的随机性来自随机误差 $\varepsilon_i$：</p><script type="math/tex; mode=display">var(y_i)=\sigma^2\tag{1.6}</script><p><strong>证明：</strong></p><script type="math/tex; mode=display">\begin{align*}var(y_i) &= var(\beta_0+\beta_1x_i+\varepsilon_i)\\&= var(\varepsilon_i)\\&= \sigma^2\end{align*}\tag{1.7}</script><p><strong>总结：</strong></p><ul><li>在假设 $\varepsilon_i$ 服从正态分布 $N(0,\sigma^2)$ 时，$y_i$ 也是独立的正态随机变量</li></ul><script type="math/tex; mode=display">y_i \text{~} N(\beta_0+\beta_1x_i,\sigma^2)\tag{1.8}</script><h2 id="1-1-最小二乘法估计回归系数"><a href="#1-1-最小二乘法估计回归系数" class="headerlink" title="1.1 最小二乘法估计回归系数"></a>1.1 最小二乘法估计回归系数</h2><p>线性拟合方程：</p><script type="math/tex; mode=display">\hat{y_i} = b_0+b_1x_i\tag{1.9}</script><p>式（1.9）中 $b_0$ 和 $b_1$ 为估计系数, $\hat{y_i}$ 为预测值。</p><script type="math/tex; mode=display">e_i=y_i-\hat{y_i}\tag{1.10}</script><p>式（1.10）中 $e_i$为误差，即真实值和预测值的差值。</p><p>损失函数：</p><script type="math/tex; mode=display">\begin{align*}\sum_{i=1}^n e_i^2 &=\sum_{i=1}^n (y_i-\hat{y_i})^2\\&= \sum_{i=1}^n (y_i-b_0-b_1x_i)^2\end{align*}\tag{1.11}</script><p>当损失函数最小时，回归系数最佳。</p><p>得正规方程：</p><script type="math/tex; mode=display">\begin{align*}\partial(\sum_{i=1}^n e_i^2)/b_0 = -2\sum_{i=1}^n (y_i-b_0+b_1x_i)=0  \\\partial(\sum_{i=1}^n e_i^2)/b_1=-2\sum_{i=1}^n x_i(y_i-b_0-b_1x_i)=0 \end{align*}\tag{1.12}</script><p>化简得：</p><script type="math/tex; mode=display">\sum_{i=1}^n y_i =  nb_0+b_1\sum_{i=1}x_i\tag{1.13}</script><script type="math/tex; mode=display">\sum_{i=1}^nx_iy_i = b_0\sum_{i=1}^nx_i + b_1\sum_{i=1}^nx_i^2\tag{1.14}</script><p><strong>易得：</strong></p><script type="math/tex; mode=display">b_0=\overline{y}-b_1\overline{x}\tag{1.15}</script><p>然后将式（1.15）代入式（1.14）得：</p><script type="math/tex; mode=display">b_1\sum_{i=1}^n(x_i-\overline{x})x_i = \sum_{i=1}^n(y_i-\overline{y})x_i\\\tag{1.16}</script><p>又因为：</p><script type="math/tex; mode=display">\begin{align*}b_1\sum_{i=1}^n(x_i-\overline{x})\overline{x}=0\\\overline{x}\sum_{i=1}^n(y_i-\overline{y})=0\end{align*}\tag{1.17}</script><p>所以：</p><script type="math/tex; mode=display">b_1\sum_{i=1}^n(x_i-\overline{x})(x_i-\overline{x})=\sum_{i=1}^n(x_i-\overline{x})(y_i-\overline{y})\tag{1.18}</script><p><strong>最终得：</strong></p><script type="math/tex; mode=display">b_1=\frac{\sum_{i=1}^n(x_i-\overline{x})(y_i-\overline{y})}{\sum_{i=1}^n(x_i-\overline{x})^2}\tag{1.19}</script><p>进一步：</p><script type="math/tex; mode=display">\begin{align*}b_1 &= \frac{\sqrt{\sum_{i=1}^n(y_i-\overline{y})^2}}{\sqrt{\sum_{i=1}^n(x_i-\overline{x})^2}}\cdot\frac{\sum_{i=1}^n(x_i-\overline{x})(y_i-\overline{y})}{\sqrt{\sum_{i=1}^n(y_i-\overline{y})^2}\sqrt{\sum_{i=1}^n(x_i-\overline{x})^2}}\\[2ex]&=\frac{\sqrt{\sum_{i=1}^n(y_i-\overline{y})^2/(n-1)}}{\sqrt{\sum_{i=1}^n(x_i-\overline{x})^2/(n-1)}}\cdot\frac{\sum_{i=1}^n(x_i-\overline{x})(y_i-\overline{y})}{\sqrt{\sum_{i=1}^n(y_i-\overline{y})^2}\sqrt{\sum_{i=1}^n(x_i-\overline{x})^2}} \\[2ex]&=\frac{s_y}{s_x}r_{xy}\end{align*}\tag{1.20}</script><p>当 $x$ 、$y$ 标准化时，即 $\overline{x}=\overline{y}=0$ ，  $s_x=s_y=1$</p><script type="math/tex; mode=display">\begin{cases}b_0 &=0\\[2ex]b_1&=r_{xy}\\\end{cases}\\[2ex]\tag{1.21}</script><script type="math/tex; mode=display">\hat{y}=r_{xy}x\tag{1.22}</script><p>对于标准化数据，$b_1$ 可以表示 $\hat{y}$ 与 $x$ 的相关程度。</p><p>为了方便后面公式推导，记</p><script type="math/tex; mode=display">\begin{align*}L_{xx}&=\sum_{i=1}^n(x_i-\overline{x})^2\\L_{xy}&=\sum_{i=1}^n(x_i-\overline{x})(y_i-\overline{y}) \\L_{yy}&=\sum_{i=1}^n(y_i-\overline{y})^2\end{align*}\tag{1.23}</script><h2 id="1-2-高斯-马尔可夫定理"><a href="#1-2-高斯-马尔可夫定理" class="headerlink" title="1.2 高斯-马尔可夫定理"></a>1.2 高斯-马尔可夫定理</h2><p>在一元线性数据中、正态误差的总体回归模型中，最小二乘估计量 $b_0$、$b_1$ 是总体参数 $\beta_0$、$\beta_1$ 的<strong>线性的、最小方差、无偏估计量</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 统计分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/posts/7fa6ac17.html"/>
      <url>/posts/7fa6ac17.html</url>
      
        <content type="html"><![CDATA[<p>R拥有许多用于存储数据的对象类型，包括<strong>标量、向量、矩阵、数组、数据框和列表</strong>。它们在存储数据的类型、创建方式、结构复杂度，以及用于<strong>定位</strong>和<strong>访问</strong>其中个别元素的标记等方面均有所不同。下图是一张R语言数据结构图。</p><p><img src="/images/1570710367409-1571623809352.png" alt=""></p><h1 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h1><p><strong>定义：</strong></p><ul><li>用于存储数值型、字符型或逻辑型数据的一维数组。向量中的<strong>元素类型必须全为数值型或者字符型或者逻辑型</strong>。向量中的单个元素称为标量，属于特殊的向量。</li></ul><p>向量是R语言中最基础，也是最重要的数据类型。</p><h2 id="向量类型"><a href="#向量类型" class="headerlink" title="向量类型"></a>向量类型</h2><ul><li>数值型向量：向量中的元素全为数字</li><li>字符型向量：向量中的元素既可以全为字符，也可以包含数字，但是这里的数字是字符串，并不是数值。</li><li>逻辑型向量：向量中的元素只有两种<code>TURE</code>或者<code>FALSE</code></li></ul><h2 id="向量的创建"><a href="#向量的创建" class="headerlink" title="向量的创建"></a>向量的创建</h2><p>数值型向量的创建</p><pre><code>c(1,2,3,4,5,6)                 1:6rep(1,3) # 重复1三次rep(1:3,3) # 重复(1,2,3)三次rep(1:3,each = 3) # 重复1,2,3各三次c(rep(1:3,3),rep(1:3,each = 3)) # 合并向量</code></pre><p>字符型向量的创建</p><pre><code>b = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)b## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot;</code></pre><p>逻辑型向量的创建</p><pre><code>c = c(TRUE, TRUE, TRUE, FALSE, TRUE, FALSE)c## [1]  TRUE  TRUE  TRUE FALSE  TRUE FALSE</code></pre><h2 id="向量中元素的访问"><a href="#向量中元素的访问" class="headerlink" title="向量中元素的访问"></a>向量中元素的访问</h2><pre><code>a = c(&quot;k&quot;, &quot;j&quot;, &quot;h&quot;, &quot;a&quot;, &quot;c&quot;, &quot;m&quot;)a[2] #向量a中第二个元素## [1] &quot;j&quot;a[c(1,2,3)] #向量a中前3个元素## [1] &quot;k&quot; &quot;j&quot; &quot;h&quot;a[1:3] #向量a中前3个元素## [1] &quot;k&quot; &quot;j&quot; &quot;h&quot;</code></pre><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><p><strong>定义：</strong></p><ul><li>矩阵是二维数组，矩阵中的元素都拥有相同的类型。大多数情况下，我们使用的矩阵就是<strong>数值型矩阵</strong>，矩阵中的元素全为数值，矩阵也可以理解为折叠起来的数值型向量。</li></ul><h2 id="矩阵的创建"><a href="#矩阵的创建" class="headerlink" title="矩阵的创建"></a>矩阵的创建</h2><pre><code>rnames = c(&#39;r1&#39;,&#39;r2&#39;,&#39;r3&#39;,&#39;r4&#39;,&#39;r5&#39;,&#39;r6&#39;)cnames = c(&#39;c1&#39;,&#39;c2&#39;,&#39;c3&#39;,&#39;c4&#39;,&#39;c5&#39;)myymatrix &lt;- matrix(1:30,                       nrow=6,                     ncol=5,                     byrow=F, # 默认按列填充                    dimnames=list(rnames, cnames)) # 行名和列名myymatrix##    c1 c2 c3 c4 c5## r1  1  7 13 19 25## r2  2  8 14 20 26## r3  3  9 15 21 27## r4  4 10 16 22 28## r5  5 11 17 23 29## r6  6 12 18 24 30</code></pre><h2 id="矩阵下标的使用"><a href="#矩阵下标的使用" class="headerlink" title="矩阵下标的使用"></a>矩阵下标的使用</h2><p>提取矩阵中第2行</p><pre><code>a1 = myymatrix[2,]a1## c1 c2 c3 c4 c5 ##  2  8 14 20 26</code></pre><p>提取矩阵中的1，3，5行</p><pre><code>a2 = myymatrix[c(1,3,5),]a2##    c1 c2 c3 c4 c5## r1  1  7 13 19 25## r3  3  9 15 21 27## r5  5 11 17 23 29</code></pre><p>提取矩阵中第2列</p><pre><code>b1 = myymatrix[,2]b1## r1 r2 r3 r4 r5 r6 ##  7  8  9 10 11 12</code></pre><p>提取矩阵中的2，4，5列</p><pre><code>b2 = myymatrix[,c(2,4,5)]b2##    c2 c4 c5## r1  7 19 25## r2  8 20 26## r3  9 21 27## r4 10 22 28## r5 11 23 29## r6 12 24 30</code></pre><p>提取任意子矩阵</p><pre><code>data = myymatrix[1:4,2:4]data##    c2 c3 c4## r1  7 13 19## r2  8 14 20## r3  9 15 21## r4 10 16 22</code></pre><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>定义：</strong></p><ul><li>数组和矩阵基本上属于一种数据类型，矩阵是特殊的数组，而数组一般指三维及以上。数组在R语言中用的很少，所以这里只写出数组的创建方法。</li></ul><h2 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h2><pre><code>dim1 = c(&#39;A1&#39;,&#39;A2&#39;)dim2 = c(&#39;B1&#39;,&#39;B2&#39;,&#39;B3&#39;)dim3 = c(&#39;C1&#39;,&#39;C2&#39;,&#39;C3&#39;,&#39;C4&#39;)data = array(1:24,             dim = c(2,3,4),             dimnames = list(dim1,dim2,dim3)) #相当于创建4个2行3列的矩阵data## , , C1## ##    B1 B2 B3## A1  1  3  5## A2  2  4  6## ## , , C2## ##    B1 B2 B3## A1  7  9 11## A2  8 10 12## ## , , C3## ##    B1 B2 B3## A1 13 15 17## A2 14 16 18## ## , , C4## ##    B1 B2 B3## A1 19 21 23## A2 20 22 24</code></pre><h1 id="数据框"><a href="#数据框" class="headerlink" title="数据框"></a>数据框</h1><p><strong>定义：</strong></p><ul><li>数据框和矩阵结构相似，由行列组成，数据框中每一列为一个成分，数据框中的成分类型分为两种：一种是向量，另外一种是因子。</li></ul><p>数据框是R中最常见的数据结构之一，一般数据处理都是基于数据框。</p><h2 id="数据框的创建"><a href="#数据框的创建" class="headerlink" title="数据框的创建"></a>数据框的创建</h2><pre><code>patientID &lt;- c(1, 2, 3, 4)age &lt;- c(25, 34, 28, 52)diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)patientdata &lt;- data.frame(patientID, age, diabetes, status)patientdata##   patientID age diabetes    status## 1         1  25    Type1      Poor## 2         2  34    Type2  Improved## 3         3  28    Type1 Excellent## 4         4  52    Type1      Poor</code></pre><h2 id="选取数据框的元素"><a href="#选取数据框的元素" class="headerlink" title="选取数据框的元素"></a>选取数据框的元素</h2><p>数据框中常见的元素选择方法有三种。</p><p><strong>方法一：</strong>和矩阵下标的使用一样，不再过多介绍。</p><p><strong>方法二：</strong></p><ul><li><p>变量名筛选</p><pre><code>patientdata[,c(&#39;age&#39;,&#39;diabetes&#39;)]##   age diabetes## 1  25    Type1## 2  34    Type2## 3  28    Type1## 4  52    Type1</code></pre></li></ul><p><strong>方法三：</strong></p><ul><li><p>使用<code>attach()</code>函数和<code>deteach()</code>函数</p><pre><code>attach(mtcars) plot(mpg, disp) detach(mtcars)</code></pre><p><img src="/images/1570963340054-1571623831314.png" alt="" style="zoom:50%;" /></p></li></ul><ul><li><p>使用<code>with()</code>函数，<code>with()</code>函数使用有一个缺点，<code>with()</code>函数里面赋值给对象需要用<code>&lt;&lt;-</code>，不能用<code>&lt;-</code>或者<code>=</code>，只有这样才可以将对象保存到全局环境中。</p><pre><code>with(mtcars, {   plot(mpg, disp) })</code></pre><p> <img src="/images/1570963382176-1571623837697.png" alt=""  /></p></li></ul><h1 id="因子"><a href="#因子" class="headerlink" title="因子"></a>因子</h1><p>在我们处理的数据中，通常将数据框中的列（成分）也称为<code>变量</code>或者属性，而行称为观测或者示例，在R中把数据框的列叫做变量更普遍。变量是统计学中的名词，在数据框中变量既可以是向量，也可以是<code>因子</code>。变量通常有三种类型，名义型（类别型）、有序型和连续型变量。</p><p><strong>变量类型：</strong></p><ul><li>名义型变量：性别有男女之分，体型有胖瘦之别，这些都是名义型（类别型）变量</li><li>有序型变量：癌症的分期有早期、中期和晚期，变量中的值有顺序之分，称为有序变量</li><li>连续型变量：人的体重就是连续型变量，表现为一定范围内的任意值，与数值型向量等价。</li></ul><p><strong>名义型变量</strong>和<strong>有序性变量</strong>在R中统称为<code>因子</code></p><h2 id="因子的创建"><a href="#因子的创建" class="headerlink" title="因子的创建"></a>因子的创建</h2><p><code>factor()</code>函数创建名义型因子</p><pre><code>sex = c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;female&quot;)sex = factor(sex)sex;class(sex)## [1] male   female male   female## Levels: female male## [1] &quot;ordered&quot; &quot;factor&quot;</code></pre><p><code>factor()</code>函数创建有序型因子 </p><pre><code>status = c(&quot;early&quot;, &quot;middle&quot;, &quot;late&quot;, &quot;late&quot;)status = factor(status,                order=TRUE,                levels=c(&quot;early&quot;, &quot;middle&quot;, &quot;late&quot;))status;class(status)## [1] early  middle late   late  ## Levels: early &lt; middle &lt; late## [1] &quot;ordered&quot; &quot;factor&quot;</code></pre><p>有时候需要将因子名称用数字表示，这时候就需要对因子重命名</p><pre><code>type = c(&quot;Type1&quot;,&quot;Type1&quot;,&quot;Type2&quot;,&quot;Type1&quot;,&quot;Type2&quot;)type = factor(type,levels = c(&quot;Type1&quot;,&quot;Type2&quot;),labels = c(1,2))</code></pre><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p><strong>定义：</strong></p><ul><li>列表是R语言中高级数据类型，列表是一些<code>对象</code>的有序集合，对象为任何一种数据类型。列表中的对象可以是向量、矩阵、数组、数据框和因子，甚至列表中也可以包含列表。</li></ul><h2 id="列表的创建"><a href="#列表的创建" class="headerlink" title="列表的创建"></a>列表的创建</h2><p>一般使用<code>list()</code>函数来创建列表</p><pre><code>g = &quot;My First List&quot; h = c(25, 26, 18, 39) j = matrix(1:10, nrow=5) k = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;) mylist = list(title=g, ages=h, j, k)mylist## $title## [1] &quot;My First List&quot;## ## $ages## [1] 25 26 18 39## ## [[3]]##      [,1] [,2]## [1,]    1    6## [2,]    2    7## [3,]    3    8## [4,]    4    9## [5,]    5   10## ## [[4]]## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot;</code></pre><h2 id="列表中对象的提取"><a href="#列表中对象的提取" class="headerlink" title="列表中对象的提取"></a>列表中对象的提取</h2><p>使用<code>mylist$age</code>和<code>mylist[[2]]</code>都表示提取<code>向量h</code></p><pre><code>mylist$age;mylist$age == mylist[[2]]## [1] 25 26 18 39## [1] TRUE TRUE TRUE TRUE</code></pre><h1 id="数据的转换"><a href="#数据的转换" class="headerlink" title="数据的转换"></a>数据的转换</h1><div class="table-container"><table><thead><tr><th>判断</th><th style="text-align:left">转换</th></tr></thead><tbody><tr><td><code>is.numeric()</code></td><td style="text-align:left"><code>as.numeric()</code></td></tr><tr><td><code>is.character()</code></td><td style="text-align:left"><code>as.character()</code></td></tr><tr><td><code>is.vector()</code></td><td style="text-align:left"><code>as.vector()</code></td></tr><tr><td><code>is.matrix()</code></td><td style="text-align:left"><code>as.matrix()</code></td></tr><tr><td><code>is.data.frame()</code></td><td style="text-align:left"><code>as.data.frame()</code></td></tr><tr><td><code>is.factor()</code></td><td style="text-align:left"><code>as.factor()</code></td></tr><tr><td><code>is.logical()</code></td><td style="text-align:left"><code>as.logical()</code></td></tr></tbody></table></div><h1 id="处理对象的通用函数"><a href="#处理对象的通用函数" class="headerlink" title="处理对象的通用函数"></a>处理对象的通用函数</h1><div class="table-container"><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><code>length(object)</code></td><td style="text-align:left">显示对象中元素/成分的数量</td></tr><tr><td style="text-align:left"><code>str(object)</code></td><td style="text-align:left">显示某个对象的结构</td></tr><tr><td style="text-align:left"><code>class(object)</code></td><td style="text-align:left">显示某个对象的类型</td></tr><tr><td style="text-align:left"><code>head(object)</code></td><td style="text-align:left">列出某个对象的开始部分</td></tr><tr><td style="text-align:left"><code>tail(object)</code></td><td style="text-align:left">列出某个对象的最后部分</td></tr><tr><td style="text-align:left"><code>ls()</code></td><td style="text-align:left">显示当前的对象列表</td></tr><tr><td style="text-align:left"><code>rm(object, object, ...)</code></td><td style="text-align:left">删除一个或更多个对象。语句<code>rm(list = ls())</code>将删除当前工作环境中的几乎所有对象</td></tr></tbody></table></div><h1 id="特殊数据"><a href="#特殊数据" class="headerlink" title="特殊数据"></a>特殊数据</h1><div class="table-container"><table><thead><tr><th>格式</th><th>含义</th><th>查看</th></tr></thead><tbody><tr><td><code>NA</code></td><td>缺失值</td><td><code>is.na()</code></td></tr><tr><td><code>NaN</code></td><td>非数字，如<code>0/0</code></td><td><code>is.nan()</code></td></tr><tr><td><code>Inf</code></td><td>无穷数，如<code>1/0</code></td><td><code>is.infinite()</code></td></tr><tr><td><code>NULL</code></td><td>空数据</td><td><code>is.null()</code></td></tr></tbody></table></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p>R语言实战（二）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
          <category> 数据科学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用工具</title>
      <link href="/posts/787e3980.html"/>
      <url>/posts/787e3980.html</url>
      
        <content type="html"><![CDATA[<p>typora</p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学</title>
      <link href="/posts/fe7e69f4.html"/>
      <url>/posts/fe7e69f4.html</url>
      
        <content type="html"><![CDATA[<p>数学</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>limma包差异表达</title>
      <link href="/posts/be4006b8.html"/>
      <url>/posts/be4006b8.html</url>
      
        <content type="html"><![CDATA[<h1 id="非原始芯片数据差异表达"><a href="#非原始芯片数据差异表达" class="headerlink" title="非原始芯片数据差异表达"></a>非原始芯片数据差异表达</h1><h2 id="GSE13507数据下载到表达矩阵"><a href="#GSE13507数据下载到表达矩阵" class="headerlink" title="GSE13507数据下载到表达矩阵"></a>GSE13507数据下载到表达矩阵</h2><h3 id="GSE13507数据下载"><a href="#GSE13507数据下载" class="headerlink" title="GSE13507数据下载"></a>GSE13507数据下载</h3><pre><code>setwd(&quot;./1.GEO_datasets/GSE13507&quot;)library(GEOquery)  gset = getGEO(&#39;GSE13507&#39;,destdir = &#39;.&#39;,getGPL = F,                AnnotGPL = T)  gset = gset[[1]]    expr = exprs(gset)        # 表达矩阵  pdata = pData(gset)       # 样本信息  gset@annotation           # 查看芯片平台</code></pre><h3 id="在GEO网站下载探针注释文件"><a href="#在GEO网站下载探针注释文件" class="headerlink" title="在GEO网站下载探针注释文件"></a>在GEO网站下载探针注释文件</h3><pre><code>probe = read.table(file = &#39;GPL6102-11574.txt&#39;,                     sep = &#39;\t&#39;,                     quote = &#39;&#39;,                     comment.char = &#39;#&#39;, # 过滤掉&#39;GPL6102-11574.txt&#39;文件中以‘#’开头的注释信息                     header = T,                     fill = T,           #  如果文件中某行的数据少于其他行，则自动添加空白域。                          stringsAsFactors = F) # 字符串不改为因子ids = probe[probe$Symbol != &#39;&#39;,              c(1,13)] # 提取探针和geneID</code></pre><h3 id="筛选探针"><a href="#筛选探针" class="headerlink" title="筛选探针"></a>筛选探针</h3><pre><code>library(dplyr)  colnames(ids)  expr = as.data.frame(expr)  expr$ID = rownames(expr)  #ids = ids[-grep(&#39;///&#39;,ids$Gene.Symbol),]      # 一个探针对应多个基因，去除  exprSet = inner_join(ids,expr,by = &#39;ID&#39;)   #  探针没有对应基因，去除library(limma)  exprSet= avereps(exprSet[,-c(1,2)],          # 多个探针对应一个基因，取均值                   ID = exprSet$Symbol)  exprSet = as.data.frame(exprSet)pdf(file = &#39;rowbox.pdf&#39;)  p &lt;- boxplot(exprSet,outline=FALSE,las=2,col = &#39;blue&#39;,xaxt = &#39;n&#39;,ann = F)  title(main = list(&#39;Before normalization&#39;,cex = 2 ,font = 2),  xlab = list(&#39;Sample list&#39;,cex = 1.5,font = 2),  ylab = &#39;&#39;,line = 0.7)  mtext(&#39;Expression value&#39;,side = 2,padj = -3,font = 2,cex = 1.5)  dev.off()</code></pre><p><img src="/images/1570064431325-1571624407656.png" alt=""></p><h3 id="分位数标准化"><a href="#分位数标准化" class="headerlink" title="分位数标准化"></a>分位数标准化</h3><pre><code>library(limma)  normalized_expr = normalizeBetweenArrays(exprSet) # 分位数标准化 method默认为quantile  #rt=log2(rt) 有时还需log2变换pdf(file = &#39;normalized_box.pdf&#39;)  p1 &lt;- boxplot(normalized_expr,outline=FALSE,las=2,col = &#39;red&#39;,xaxt = &#39;n&#39;,ann = F)  title(main = list(&#39;Normalization&#39;,cex = 2 ,font = 2),        xlab = list(&#39;Sample list&#39;,cex = 1.5,font = 2),        ylab = &#39;&#39;,line = 0.7)  mtext(&#39;Expression value&#39;,side = 2,padj = -3,font = 2,cex = 1.5)  dev.off()</code></pre><p><img src="/images/1570064471270-1571624433712.png" alt=""></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><pre><code>group_list = pdata$title  #table(pdata$title) # 查看样品信息  control      = normalized_expr[,grep(&#39;Control&#39;,group_list)]  surrounding  = normalized_expr[,grep(&#39;Surrounding&#39;,group_list)]  cancer       = normalized_expr[,grep(&#39;cancer&#39;,group_list)]  tumor        = normalized_expr[,grep(&#39;tumor&#39;,group_list)]  exprSet1 = cbind(cancer,tumor,control,surrounding)  group_list = c(rep(&#39;tumor&#39;,ncol(cancer) + ncol(tumor)),                 rep(&#39;normal&#39;,ncol(control) + ncol(surrounding)))</code></pre><h2 id="差异表达"><a href="#差异表达" class="headerlink" title="差异表达"></a>差异表达</h2><h3 id="表达矩阵"><a href="#表达矩阵" class="headerlink" title="表达矩阵"></a>表达矩阵</h3><pre><code>data = exprSet1</code></pre><h3 id="分组矩阵"><a href="#分组矩阵" class="headerlink" title="分组矩阵"></a>分组矩阵</h3><pre><code>group_list = factor(group_list)design &lt;- model.matrix( ~0 + group_list)colnames( design ) = levels(group_list)rownames( design ) = colnames(data)contrast.matrix &lt;- makeContrasts( &quot;tumor-normal&quot;, levels = design)</code></pre><h3 id="差异表达矩阵"><a href="#差异表达矩阵" class="headerlink" title="差异表达矩阵"></a>差异表达矩阵</h3><pre><code>fit &lt;- lmFit( data, design )fit2 &lt;- contrasts.fit( fit, contrast.matrix ) fit2 &lt;- eBayes( fit2 )allDiff=topTable(fit2,adjust=&#39;fdr&#39;,number=200000)write.table(allDiff,file=&quot;alldiff.xls&quot;,sep=&quot;\t&quot;,quote=F)</code></pre><h1 id="mRNA-seq数据差异表达"><a href="#mRNA-seq数据差异表达" class="headerlink" title="mRNA-seq数据差异表达"></a>mRNA-seq数据差异表达</h1><h2 id="GBM表达矩阵下载"><a href="#GBM表达矩阵下载" class="headerlink" title="GBM表达矩阵下载"></a>GBM表达矩阵下载</h2><pre><code>library(TCGAbiolinks) library(SummarizedExperiment) query &lt;- GDCquery(project = &#39;TCGA-GBM&#39;,                    data.category = &quot;Transcriptome Profiling&quot;,                    data.type = &quot;Gene Expression Quantification&quot;,                    workflow.type = &quot;HTSeq - Counts&quot;)GDCdownload(query, method = &quot;api&quot;, files.per.chunk = 100)expdat &lt;- GDCprepare(query = query)expr = assay(expdat)expr = as.data.frame(expr)save(expr,file = &#39;expr.Rdata&#39;)</code></pre><h2 id="提取mRNA数据"><a href="#提取mRNA数据" class="headerlink" title="提取mRNA数据"></a>提取mRNA数据</h2><pre><code>{  library(rtracklayer)  library(dplyr)  gtf &lt;- import(&#39;Homo_sapiens.GRCh38.98.chr.gtf.gz&#39;)   gtf_df &lt;- as.data.frame(gtf)    gene_df &lt;- select(gtf_df,                    c(gene_id,gene_name,gene_biotype))    index &lt;- duplicated(gene_df$gene_id)   gene_df = gene_df[!index,]  dim(gene_df)  mRNA = gene_df[gene_df$gene_biotype == &#39;protein_coding&#39;,1]  exprSet = expr[na.omit(match(mRNA,rownames(expr))),]}</code></pre><h2 id="分组-1"><a href="#分组-1" class="headerlink" title="分组"></a>分组</h2><pre><code># 癌症组织和癌旁组织library(stringr)tumor &lt;- colnames(exprSet)[as.integer(substr(colnames(exprSet),14,15)) &lt; 10]normal &lt;- colnames(exprSet)[as.integer(substr(colnames(exprSet),14,15)) &gt;= 10]tumor_sample &lt;- exprSet[,tumor]normal_sample &lt;- exprSet[,normal]exprSet_by_group &lt;- cbind(tumor_sample,normal_sample)group_list &lt;- c(rep(&#39;tumor&#39;,ncol(tumor_sample)),rep(&#39;normal&#39;,ncol(normal_sample)))</code></pre><h2 id="差异表达-1"><a href="#差异表达-1" class="headerlink" title="差异表达"></a>差异表达</h2><h3 id="表达矩阵-1"><a href="#表达矩阵-1" class="headerlink" title="表达矩阵"></a>表达矩阵</h3><pre><code>data = exprSet_by_group</code></pre><h3 id="分组矩阵-1"><a href="#分组矩阵-1" class="headerlink" title="分组矩阵"></a>分组矩阵</h3><pre><code>group_list = factor(group_list)design &lt;- model.matrix( ~0 + group_list)colnames( design ) = levels(group_list)rownames( design ) = colnames(data)</code></pre><h3 id="差异表达矩阵-1"><a href="#差异表达矩阵-1" class="headerlink" title="差异表达矩阵"></a>差异表达矩阵</h3><pre><code>DGElist &lt;- DGEList( counts = data)keep &lt;- filterByExpr(DGElist, design) # 过滤低表达量基因DGElist &lt;- DGElist[ keep_gene, , keep.lib.sizes = FALSE ]DGElist &lt;- calcNormFactors( DGElist ) # 表达矩阵TMM标准化v &lt;- voom(DGElist, design)fit &lt;- lmFit(v, design)cont.matrix &lt;- makeContrasts(contrasts = c(&#39;tumor-normal&#39;), levels = design)fit &lt;- contrasts.fit(fit, cont.matrix)fit &lt;- eBayes(fit)nrDEG_limma_voom = topTable(fit, coef = &#39;tumor-normal&#39;,n = Inf)</code></pre><h2 id="注释文件下载地址"><a href="#注释文件下载地址" class="headerlink" title="注释文件下载地址"></a>注释文件下载地址</h2><p><a href="http://ftp.ensembl.org/pub/" target="_blank" rel="noopener">HG38-gtf</a></p>]]></content>
      
      
      <categories>
          
          <category> 转录组 </category>
          
          <category> R包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 差异表达 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习</title>
      <link href="/posts/33115a55.html"/>
      <url>/posts/33115a55.html</url>
      
        <content type="html"><![CDATA[<p>DEEP</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="/posts/498ab7d9.html"/>
      <url>/posts/498ab7d9.html</url>
      
        <content type="html"><![CDATA[<p>ML</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/posts/9211474f.html"/>
      <url>/posts/9211474f.html</url>
      
        <content type="html"><![CDATA[<p>linux</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python</title>
      <link href="/posts/a4d4b8b8.html"/>
      <url>/posts/a4d4b8b8.html</url>
      
        <content type="html"><![CDATA[<p>PY</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
